{
  "version": 3,
  "sources": ["src/buffer.js", "src/lowlevel.js", "src/shared.js", "src/support.js", "src/o-encoder.js", "src/xhr.js", "src/o-decoder.js", "src/polyfill.js"],
  "sourcesContent": ["\n/**\n * @param {Uint8Array} bytes\n * @param {string} encoding\n * @return {string}\n */\nexport function decodeBuffer(bytes, encoding) {\n  /** @type {Buffer} */\n  var b;\n  if (bytes instanceof Buffer) {\n    // @ts-ignore\n    b = bytes;\n  } else {\n    b = Buffer.from(bytes.buffer, bytes.byteOffset, bytes.byteLength);\n  }\n  return b.toString(/** @type {BufferEncoding} */(encoding));\n}\n\n\n/**\n * @param {string} string\n * @return {Uint8Array}\n */\nexport var encodeBuffer = (string) => Buffer.from(string);\n", "\n/**\n * @param {Uint8Array} bytes\n * @return {string}\n */\nexport function decodeFallback(bytes) {\n  var inputIndex = 0;\n\n  // Create a working buffer for UTF-16 code points, but don't generate one\n  // which is too large for small input sizes. UTF-8 to UCS-16 conversion is\n  // going to be at most 1:1, if all code points are ASCII. The other extreme\n  // is 4-byte UTF-8, which results in two UCS-16 points, but this is still 50%\n  // fewer entries in the output.\n  var pendingSize = Math.min(256 * 256, bytes.length + 1);\n  var pending = new Uint16Array(pendingSize);\n  var chunks = [];\n  var pendingIndex = 0;\n\n  for (; ;) {\n    var more = inputIndex < bytes.length;\n\n    // If there's no more data or there'd be no room for two UTF-16 values,\n    // create a chunk. This isn't done at the end by simply slicing the data\n    // into equal sized chunks as we might hit a surrogate pair.\n    if (!more || (pendingIndex >= pendingSize - 1)) {\n      // nb. .apply and friends are *really slow*. Low-hanging fruit is to\n      // expand this to literally pass pending[0], pending[1], ... etc, but\n      // the output code expands pretty fast in this case.\n      // These extra vars get compiled out: they're just to make TS happy.\n      // Turns out you can pass an ArrayLike to .apply().\n      var subarray = pending.subarray(0, pendingIndex);\n      var arraylike = /** @type {number[]} */ (/** @type {unknown} */ (subarray));\n      chunks.push(String.fromCharCode.apply(null, arraylike));\n\n      if (!more) {\n        return chunks.join('');\n      }\n\n      // Move the buffer forward and create another chunk.\n      bytes = bytes.subarray(inputIndex);\n      inputIndex = 0;\n      pendingIndex = 0;\n    }\n\n    // The native TextDecoder will generate \"REPLACEMENT CHARACTER\" where the\n    // input data is invalid. Here, we blindly parse the data even if it's\n    // wrong: e.g., if a 3-byte sequence doesn't have two valid continuations.\n\n    var byte1 = bytes[inputIndex++];\n    if ((byte1 & 0x80) === 0) {  // 1-byte or null\n      pending[pendingIndex++] = byte1;\n    } else if ((byte1 & 0xe0) === 0xc0) {  // 2-byte\n      var byte2 = bytes[inputIndex++] & 0x3f;\n      pending[pendingIndex++] = ((byte1 & 0x1f) << 6) | byte2;\n    } else if ((byte1 & 0xf0) === 0xe0) {  // 3-byte\n      var byte2 = bytes[inputIndex++] & 0x3f;\n      var byte3 = bytes[inputIndex++] & 0x3f;\n      pending[pendingIndex++] = ((byte1 & 0x1f) << 12) | (byte2 << 6) | byte3;\n    } else if ((byte1 & 0xf8) === 0xf0) {  // 4-byte\n      var byte2 = bytes[inputIndex++] & 0x3f;\n      var byte3 = bytes[inputIndex++] & 0x3f;\n      var byte4 = bytes[inputIndex++] & 0x3f;\n\n      // this can be > 0xffff, so possibly generate surrogates\n      var codepoint = ((byte1 & 0x07) << 0x12) | (byte2 << 0x0c) | (byte3 << 0x06) | byte4;\n      if (codepoint > 0xffff) {\n        // codepoint &= ~0x10000;\n        codepoint -= 0x10000;\n        pending[pendingIndex++] = (codepoint >>> 10) & 0x3ff | 0xd800;\n        codepoint = 0xdc00 | codepoint & 0x3ff;\n      }\n      pending[pendingIndex++] = codepoint;\n    } else {\n      // invalid initial byte\n    }\n  }\n}\n\n\n/**\n * @param {string} string\n * @return {Uint8Array}\n */\nexport function encodeFallback(string) {\n  var pos = 0;\n  var len = string.length;\n\n  var at = 0;  // output position\n  var tlen = Math.max(32, len + (len >>> 1) + 7);  // 1.5x size\n  var target = new Uint8Array((tlen >>> 3) << 3);  // ... but at 8 byte offset\n\n  while (pos < len) {\n    var value = string.charCodeAt(pos++);\n    if (value >= 0xd800 && value <= 0xdbff) {\n      // high surrogate\n      if (pos < len) {\n        var extra = string.charCodeAt(pos);\n        if ((extra & 0xfc00) === 0xdc00) {\n          ++pos;\n          value = ((value & 0x3ff) << 10) + (extra & 0x3ff) + 0x10000;\n        }\n      }\n      if (value >= 0xd800 && value <= 0xdbff) {\n        continue;  // drop lone surrogate\n      }\n    }\n\n    // expand the buffer if we couldn't write 4 bytes\n    if (at + 4 > target.length) {\n      tlen += 8;  // minimum extra\n      tlen *= (1.0 + (pos / string.length) * 2);  // take 2x the remaining\n      tlen = (tlen >>> 3) << 3;  // 8 byte offset\n\n      var update = new Uint8Array(tlen);\n      update.set(target);\n      target = update;\n    }\n\n    if ((value & 0xffffff80) === 0) {  // 1-byte\n      target[at++] = value;  // ASCII\n      continue;\n    } else if ((value & 0xfffff800) === 0) {  // 2-byte\n      target[at++] = ((value >>> 6) & 0x1f) | 0xc0;\n    } else if ((value & 0xffff0000) === 0) {  // 3-byte\n      target[at++] = ((value >>> 12) & 0x0f) | 0xe0;\n      target[at++] = ((value >>> 6) & 0x3f) | 0x80;\n    } else if ((value & 0xffe00000) === 0) {  // 4-byte\n      target[at++] = ((value >>> 18) & 0x07) | 0xf0;\n      target[at++] = ((value >>> 12) & 0x3f) | 0x80;\n      target[at++] = ((value >>> 6) & 0x3f) | 0x80;\n    } else {\n      continue;  // out of range\n    }\n\n    target[at++] = (value & 0x3f) | 0x80;\n  }\n\n  // Use subarray if slice isn't supported (IE11). This will use more memory\n  // because the original array still exists.\n  return target.slice ? target.slice(0, at) : target.subarray(0, at);\n}\n", "\nexport var failedToString = 'Failed to ';\n\n/**\n * @param {boolean|undefined} check \n * @param {string} operation \n * @param {string} fieldName \n */\nexport var maybeThrowFailedToOption = (check, operation, fieldName) => {\n  if (check) {\n    throw new Error(`${failedToString}${operation}: the '${fieldName}' option is unsupported.`);\n  }\n};", "\nexport var hasBufferFrom = (typeof Buffer === 'function' && Buffer.from);", "import { encodeBuffer } from './buffer.js';\n